<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>Glitching Case Study</title>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <link href="http://www.google.com/favicon.ico"
        type="image/x-icon"
        rel="shortcut icon" />

<script type="text/javascript" src="https://www.corp.google.com/eng/techpubs/include/designdoc_template.js"></script>
<!-- Accessibility jump -->
<style type="text/css">
.hidden { 
  position: relative; top: -9999px; left: -9999px;
  display: block; height: 0px; width: 0px; overflow: hidden; 
  }
</style>
</head>

<body>


<h2>Audio Glitching Case Study</h2>

<img src="client3d.3.png">
<p>
  A prototype was created on Mac OS X to determine the feasibility and performance behavior of the proposed model of using Native Client along with an "Audio Service" process to render fairly low-latency, glitch-free audio.  The prototype is not using Native Client, instead using POSIX shared memory and Mach messages directly.  But the general issues being studied here can be generalized to possible Native Client implementations for Windows XP, Mac OS X, and Linux.  Using the prototype, it was found that a fairly low-latency, glitch free system is possible if great
care is taken in setting the thread priorities and scheduling policies.
</p>  
  
<p>  
  In this prototype an <b>AudioPlayer</b> process represents the Client Audio Service and an
  <b>audio_remote_client</b> process represents a nacl module in the above diagram.  The <b>audio_remote_client</b> generates a real-time audio stream (a continuous 440Hz tone).  A tone was chosen to be able to easily hear the glitches.  Each buffer was 128 sample-frames with the system running at 44.1KHz sample rate.  Per-buffer CPU load of the <b>audio_remote_client</b> was stressed from around 1% to 95% of real-time to simulate computationally intensive audio processing.
  In addition, the system was stressed during the tests by running several other applications such as Google Earth, iTunes, in order to give the <b>audio_remote_client's</b> DSP thread some competition.   The goal here was to try to detect audio glitching.
  At first no attempt was made to set the <b>audio_remote_client</b>'s thread priority.  On a multi-core machine (four cores),
  this actually worked better than expected with audio only occasionally glitching even after stressing the system quite a bit by running other
  CPU intensive applications.  But, when all of the cores except one was disabled, it was quite easy to hear glitching even
  with moderate CPU load.  
</p>

<br>

<h4>Importance of Thread Priority</h4>
System traces using the performance tool "Shark" were taken to observe thread scheduling behavior.  As the diagrams below indicate, it is <b>essential</b> to carefully control the thread priorities and time-constraint policies in both
the <b>audio_remote_client</b> and the <b>AudioPlayer</b> processes in order to avoid audio glitching.  Failing to do so will result in objectionable audio glitching
when the system is put under a moderate load as might be the case in a typical game.  
<p>
  When all of the cores except one was disabled (simulating the common case of a single-core machine), it was quite easy to hear glitching even
  with moderate CPU load:
</p>


<br>

<h4>Scheduling Timeline with Glitches </h4>
<img src="SystemTrace-bad.png">

<p>
Massive audio glitching caused by terrible thread scheduling latency on a single-core system.  More than
four buffers worth of audio are missed here!  And this is a microscopic snapshot of hundreds of these
occurrences.  Very loud and objectionable audio artifacts are the result.
</p>

<br><br><br>


In the single-core case, the glitching was eliminated by setting the <b>audio_remote_client</b> process
to a high priority (63):

<br>
<pre>  thread_policy_set(... THREAD_PRECEDENCE_POLICY ...); </pre>

  and setting real-time constraints:

<pre>  thread_policy_set(... THREAD_TIME_CONSTRAINT_POLICY ...);</pre>


The time-constraint policy gives a thread a guaranteed percentage in a given time quantum.
<br>
<p>
  With this change we see a much more regular scheduling pattern, allowing the audio stream to be played back glitch-free:
</p>

<h4>Scheduling Timeline No Glitches </h4>

<img src="SystemTrace-good.png">

<p>
Note the periodic and timely scheduling of both the <b>AudioPlayer</b> thread (line 3) and the <b>audio_remote_client</b>
thread (line 1).  This shows that the periodic callback in the <b>AudioPlayer</b> causes the <b>audio_remote_client</b>
to be scheduled practically immediately...  The result is that the audio stream generated by <b>audio_remote_client</b> is sent to the audio hardware with no glitches.
</p>

<br><br><br>

Thus it is possible to get pretty good performance using such a model, assuming that the thread priorities and scheduling policies are managed carefully.

<br><br><br>

</body>
</html>
